// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package mock

import (
	"sync"
)

var (
	lockRegistratorMockDeregister sync.RWMutex
	lockRegistratorMockRegister   sync.RWMutex
)

// RegistratorMock is a mock implementation of Registrator.
//
//     func TestSomethingThatUsesRegistrator(t *testing.T) {
//
//         // make and configure a mocked Registrator
//         mockedRegistrator := &RegistratorMock{
//             DeregisterFunc: func(ID string) error {
// 	               panic("TODO: mock out the Deregister method")
//             },
//             RegisterFunc: func(ID string, address string, tags ...string) error {
// 	               panic("TODO: mock out the Register method")
//             },
//         }
//
//         // TODO: use mockedRegistrator in code that requires Registrator
//         //       and then make assertions.
//
//     }
type RegistratorMock struct {
	// DeregisterFunc mocks the Deregister method.
	DeregisterFunc func(ID string) error

	// RegisterFunc mocks the Register method.
	RegisterFunc func(ID string, address string, tags ...string) error

	// calls tracks calls to the methods.
	calls struct {
		// Deregister holds details about calls to the Deregister method.
		Deregister []struct {
			// ID is the ID argument value.
			ID string
		}
		// Register holds details about calls to the Register method.
		Register []struct {
			// ID is the ID argument value.
			ID string
			// Address is the address argument value.
			Address string
			// Tags is the tags argument value.
			Tags []string
		}
	}
}

// Deregister calls DeregisterFunc.
func (mock *RegistratorMock) Deregister(ID string) error {
	if mock.DeregisterFunc == nil {
		panic("moq: RegistratorMock.DeregisterFunc is nil but Registrator.Deregister was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockRegistratorMockDeregister.Lock()
	mock.calls.Deregister = append(mock.calls.Deregister, callInfo)
	lockRegistratorMockDeregister.Unlock()
	return mock.DeregisterFunc(ID)
}

// DeregisterCalls gets all the calls that were made to Deregister.
// Check the length with:
//     len(mockedRegistrator.DeregisterCalls())
func (mock *RegistratorMock) DeregisterCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockRegistratorMockDeregister.RLock()
	calls = mock.calls.Deregister
	lockRegistratorMockDeregister.RUnlock()
	return calls
}

// Register calls RegisterFunc.
func (mock *RegistratorMock) Register(ID string, address string, tags ...string) error {
	if mock.RegisterFunc == nil {
		panic("moq: RegistratorMock.RegisterFunc is nil but Registrator.Register was just called")
	}
	callInfo := struct {
		ID      string
		Address string
		Tags    []string
	}{
		ID:      ID,
		Address: address,
		Tags:    tags,
	}
	lockRegistratorMockRegister.Lock()
	mock.calls.Register = append(mock.calls.Register, callInfo)
	lockRegistratorMockRegister.Unlock()
	return mock.RegisterFunc(ID, address, tags...)
}

// RegisterCalls gets all the calls that were made to Register.
// Check the length with:
//     len(mockedRegistrator.RegisterCalls())
func (mock *RegistratorMock) RegisterCalls() []struct {
	ID      string
	Address string
	Tags    []string
} {
	var calls []struct {
		ID      string
		Address string
		Tags    []string
	}
	lockRegistratorMockRegister.RLock()
	calls = mock.calls.Register
	lockRegistratorMockRegister.RUnlock()
	return calls
}
